<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Blackjack Counter Pro - Motor Completo</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; -webkit-user-select:none; user-select:none; }
    body { font-family:-apple-system,BlinkMacSystemFont,sans-serif; background:linear-gradient(135deg,#0f2027,#203a43,#2c5364); color:#fff; min-height:100vh; padding:16px; }
    .container { max-width:900px; margin:0 auto; }
    h1 { font-size:28px; text-align:center; margin-bottom:8px; background:linear-gradient(135deg,#4ade80,#60a5fa); -webkit-background-clip:text; -webkit-text-fill-color:transparent; }
    .subtitle { text-align:center; font-size:11px; opacity:0.6; margin-bottom:20px; }
    .box { background:rgba(255,255,255,0.1); backdrop-filter:blur(10px); border-radius:16px; padding:20px; margin-bottom:16px; }
    .stats { display:grid; grid-template-columns:repeat(6,1fr); gap:8px; margin-bottom:16px; }
    .stat { background:rgba(255,255,255,0.1); padding:10px; border-radius:10px; text-align:center; }
    .stat-label { font-size:9px; opacity:0.7; text-transform:uppercase; margin-bottom:4px; }
    .stat-value { font-size:18px; font-weight:900; }
    .positive { color:#4ade80; }
    .negative { color:#ef4444; }
    .neutral { color:#60a5fa; }
    .warning { color:#fbbf24; }
    .btn { padding:12px 16px; font-size:14px; font-weight:800; border:none; border-radius:10px; cursor:pointer; text-transform:uppercase; }
    .btn-primary { background:linear-gradient(135deg,#4ade80,#22c55e); color:#000; }
    .btn-secondary { background:linear-gradient(135deg,#60a5fa,#3b82f6); color:#fff; }
    .btn-danger { background:linear-gradient(135deg,#ef4444,#dc2626); color:#fff; }
    .btn-warning { background:linear-gradient(135deg,#fbbf24,#f59e0b); color:#000; }
    .flex { display:flex; gap:8px; flex-wrap:wrap; margin-bottom:16px; }
    .cards { display:grid; grid-template-columns:repeat(13,1fr); gap:6px; margin-bottom:16px; }
    .card { aspect-ratio:1; font-size:18px; font-weight:900; border:none; border-radius:10px; cursor:pointer; color:#fff; border:2px solid rgba(255,255,255,0.2); }
    .card.low { background:linear-gradient(135deg,#4ade80,#22c55e); }
    .card.mid { background:linear-gradient(135deg,#60a5fa,#3b82f6); }
    .card.high { background:linear-gradient(135deg,#ef4444,#dc2626); }
    .ai { background:linear-gradient(135deg,rgba(74,222,128,0.2),rgba(34,197,94,0.15)); border:2px solid rgba(74,222,128,0.4); border-radius:12px; padding:14px; margin-bottom:16px; position:relative; }
    .ai::before { content:'ü§ñ'; position:absolute; top:10px; right:14px; font-size:18px; }
    .ai-action { font-size:24px; font-weight:900; margin-bottom:6px; }
    .ai-reason { font-size:12px; opacity:0.8; line-height:1.4; }
    .alert { background:rgba(251,191,36,0.2); border:2px solid rgba(251,191,36,0.5); border-radius:12px; padding:12px; margin-bottom:16px; }
    .alert-text { font-size:13px; line-height:1.5; }
    .log { background:rgba(0,0,0,0.4); border-radius:10px; padding:12px; max-height:200px; overflow-y:auto; font-size:11px; line-height:1.6; font-family:monospace; }
    .log-entry { padding:4px 0; border-bottom:1px solid rgba(255,255,255,0.1); }
    .config-grid { display:grid; gap:12px; }
    .form-group { margin-bottom:12px; }
    .form-label { font-size:12px; font-weight:700; margin-bottom:6px; display:block; }
    .form-input, .form-select { width:100%; padding:8px; border-radius:8px; border:2px solid rgba(255,255,255,0.2); background:rgba(0,0,0,0.3); color:#fff; font-size:14px; }
    .checkbox { display:flex; align-items:center; gap:8px; padding:8px; background:rgba(0,0,0,0.3); border-radius:8px; cursor:pointer; }
    .checkbox input { width:18px; height:18px; cursor:pointer; }
    .hidden { display:none !important; }
    details { margin-bottom:16px; }
    summary { cursor:pointer; padding:10px; background:rgba(255,255,255,0.1); border-radius:8px; font-weight:700; }
  </style>
</head>
<body>
<div class="container">
  <h1>‚ô†Ô∏è BLACKJACK COUNTER PRO</h1>
  <div class="subtitle">Motor Completo: Hi-Lo + Illustrious 18 + Humanizer + Auto-Sim</div>

  <div class="stats">
    <div class="stat">
      <div class="stat-label">RC</div>
      <div class="stat-value neutral" id="rc">0</div>
    </div>
    <div class="stat">
      <div class="stat-label">TC</div>
      <div class="stat-value neutral" id="tc">0</div>
    </div>
    <div class="stat">
      <div class="stat-label">Apuesta</div>
      <div class="stat-value neutral" id="bet">$10</div>
    </div>
    <div class="stat">
      <div class="stat-label">Banco</div>
      <div class="stat-value neutral" id="bank">$1000</div>
    </div>
    <div class="stat">
      <div class="stat-label">Penetraci√≥n</div>
      <div class="stat-value neutral" id="penetration">0%</div>
    </div>
    <div class="stat">
      <div class="stat-label">Modo</div>
      <div class="stat-value neutral" id="mode">Manual</div>
    </div>
  </div>

  <div class="alert hidden" id="alert">
    <div class="alert-text" id="alertText"></div>
  </div>

  <div class="flex">
    <button class="btn btn-primary" onclick="toggleAuto()">‚ñ∂Ô∏è AUTO-SIMULAR</button>
    <button class="btn btn-secondary" onclick="newHand()">‚è≠Ô∏è NUEVA MANO</button>
    <button class="btn btn-warning" onclick="shuffle()">üîÑ SHUFFLE</button>
    <button class="btn btn-danger" onclick="resetAll()">‚Üª RESET</button>
  </div>

  <div class="box">
    <h3 style="margin-bottom:12px;">Cartas Vistas (Click para registrar)</h3>
    <div class="cards" id="cardGrid"></div>
  </div>

  <div class="ai" id="ai">
    <div class="ai-action" id="aiAction">Esperando cartas...</div>
    <div class="ai-reason" id="aiReason">Sistema listo para analizar</div>
  </div>

  <details>
    <summary>‚öôÔ∏è CONFIGURACI√ìN AVANZADA</summary>
    <div class="box config-grid">
      <div class="form-group">
        <label class="form-label">N√∫mero de Mazos</label>
        <select class="form-select" id="numDecks" onchange="updateConfig()">
          <option value="1">1 mazo</option>
          <option value="2">2 mazos</option>
          <option value="4">4 mazos</option>
          <option value="6" selected>6 mazos</option>
          <option value="8">8 mazos</option>
        </select>
      </div>
      <div class="form-group">
        <label class="form-label">Penetraci√≥n del Zapato (%)</label>
        <input type="number" class="form-input" id="penetrationPct" value="75" min="50" max="95" onchange="updateConfig()">
      </div>
      <div class="form-group">
        <label class="form-label">Bankroll Inicial ($)</label>
        <input type="number" class="form-input" id="initialBank" value="1000" min="100" onchange="updateConfig()">
      </div>
      <div class="form-group">
        <label class="form-label">Apuesta M√≠nima ($)</label>
        <input type="number" class="form-input" id="minBet" value="10" min="1" onchange="updateConfig()">
      </div>
      <div class="form-group">
        <label class="form-label">Modo de Juego</label>
        <select class="form-select" id="playMode" onchange="updateConfig()">
          <option value="optimal">√ìptimo (100% perfecto)</option>
          <option value="realistic" selected>Realista (errores humanos)</option>
          <option value="training">Entrenamiento</option>
        </select>
      </div>
      <div class="form-group">
        <label class="form-label">Tasa de Errores (%) - Solo modo Realista</label>
        <input type="number" class="form-input" id="errorRate" value="3" min="0" max="15" onchange="updateConfig()">
      </div>
      <label class="checkbox">
        <input type="checkbox" id="dealerHitsSoft17" onchange="updateConfig()">
        <span>Dealer hits soft 17</span>
      </label>
      <label class="checkbox">
        <input type="checkbox" id="doubleAfterSplit" checked onchange="updateConfig()">
        <span>Double after split</span>
      </label>
      <label class="checkbox">
        <input type="checkbox" id="surrender" checked onchange="updateConfig()">
        <span>Late surrender</span>
      </label>
      <label class="checkbox">
        <input type="checkbox" id="resplitAces" onchange="updateConfig()">
        <span>Resplit aces</span>
      </label>
    </div>
  </details>

  <details>
    <summary>üìä ESTAD√çSTICAS DE SESI√ìN</summary>
    <div class="box">
      <div style="display:grid; grid-template-columns:repeat(3,1fr); gap:12px; text-align:center;">
        <div>
          <div style="font-size:11px; opacity:0.7;">Manos Jugadas</div>
          <div style="font-size:24px; font-weight:900;" id="totalHands">0</div>
        </div>
        <div>
          <div style="font-size:11px; opacity:0.7;">Ganancia/P√©rdida</div>
          <div style="font-size:24px; font-weight:900;" id="profit">$0</div>
        </div>
        <div>
          <div style="font-size:11px; opacity:0.7;">Win Rate</div>
          <div style="font-size:24px; font-weight:900;" id="winRate">0%</div>
        </div>
      </div>
    </div>
  </details>

  <details>
    <summary>üìã REGISTRO DE JUEGO</summary>
    <div class="log" id="log"></div>
  </details>
</div>

<script>
// ==================== CORE ENGINE ====================

// 1. RULES
const RULES = {
  decks: 6,
  penetration: 0.75,
  dealerHitsSoft17: false,
  doubleAfterSplit: true,
  surrender: true,
  resplitAces: false,
  bankroll: 1000,
  minBet: 10,
  playMode: 'realistic',
  errorRate: 3
};

// 2. HI-LO SYSTEM
const HI_LO = {
  '2':1, '3':1, '4':1, '5':1, '6':1,
  '7':0, '8':0, '9':0,
  '10':-1, 'J':-1, 'Q':-1, 'K':-1, 'A':-1
};

const CARD_VALUES = {
  '2':2, '3':3, '4':4, '5':5, '6':6, '7':7, '8':8, '9':9,
  '10':10, 'J':10, 'Q':10, 'K':10, 'A':11
};

const ALL_CARDS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];

// 3. ILLUSTRIOUS 18
const ILLUSTRIOUS_18 = {
  'insurance': 3,
  '16v10': 0,
  '15v10': 4,
  '13v2': -1,
  '13v3': -2,
  '12v2': 3,
  '12v3': 2,
  '12v4': 0,
  '12v5': -2,
  '12v6': -1,
  '11vA': 1,
  '10v10': 4,
  '10vA': 4,
  '9v2': 1,
  '9v7': 3,
  '20v5': 5,
  '20v6': 4,
  '16v9': 5
};

// 4. STATE
let state = {
  runningCount: 0,
  cardsPlayed: 0,
  currentBankroll: 1000,
  handsPlayed: 0,
  handsWon: 0,
  handsLost: 0,
  autoMode: false,
  gameLog: [],
  lastHand: { player: [], dealer: [] }
};

// 5. SHOE CLASS
class Shoe {
  constructor(numDecks) {
    this.numDecks = numDecks;
    this.totalCards = numDecks * 52;
    this.reset();
  }
  
  reset() {
    this.cards = [];
    for(let d = 0; d < this.numDecks; d++) {
      for(let suit = 0; suit < 4; suit++) {
        ALL_CARDS.forEach(card => this.cards.push(card));
      }
    }
    this.shuffle();
  }
  
  shuffle() {
    for(let i = this.cards.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]];
    }
  }
  
  draw() {
    if(this.cards.length === 0) this.reset();
    return this.cards.pop();
  }
  
  needsShuffle(penetration) {
    return (this.cards.length / this.totalCards) < (1 - penetration);
  }
}

let shoe = new Shoe(RULES.decks);

// 6. COUNTER
class Counter {
  static trueCount(rc, cardsPlayed, totalCards) {
    const decksRemaining = Math.max(0.5, (totalCards - cardsPlayed) / 52);
    return Math.trunc(rc / decksRemaining); // Truncamiento profesional
  }
  
  static updateCount(card) {
    state.runningCount += HI_LO[card];
    state.cardsPlayed++;
  }
}

// 7. BANKROLL
class Bankroll {
  static getBet(tc) {
    const edge = tc * 0.005; // ~0.5% edge per TC
    let bet = RULES.minBet;
    
    if(tc <= 0) return RULES.minBet;
    
    // Kelly-based betting
    if(edge > 0 && RULES.playMode !== 'training') {
      const kellyFraction = 0.5;
      const kellyBet = state.currentBankroll * edge * kellyFraction;
      bet = Math.max(RULES.minBet, Math.min(kellyBet, RULES.minBet * 10));
    } else {
      // Spread simple
      if(tc === 1) bet = RULES.minBet * 2;
      else if(tc === 2) bet = RULES.minBet * 3;
      else if(tc === 3) bet = RULES.minBet * 5;
      else if(tc >= 4) bet = RULES.minBet * 8;
    }
    
    return Math.round(bet);
  }
  
  static win(amount) {
    state.currentBankroll += amount;
    state.handsWon++;
  }
  
  static lose(amount) {
    state.currentBankroll -= amount;
    state.handsLost++;
  }
  
  static push() {
    // No cambia bankroll
  }
}

// 8. HUMANIZER (ERRORES REALISTAS)
class Humanizer {
  static shouldMakeError(tc, betSize, handsPlayed) {
    if(RULES.playMode !== 'realistic') return false;
    
    let errorProb = RULES.errorRate / 100;
    
    // M√°s errores cuando:
    if(tc <= 0) errorProb *= 1.5; // Conteo neutral/negativo
    if(handsPlayed > 200) errorProb *= 1.2; // Fatiga
    if(betSize > RULES.minBet * 5) errorProb *= 0.5; // Cuidado con apuestas altas
    
    // Nunca errores cuando TC >= +4 (oportunidad cr√≠tica)
    if(tc >= 4) errorProb = 0;
    
    return Math.random() < errorProb;
  }
  
  static introduceError(optimalAction) {
    const alternatives = {
      'HIT': ['STAND'],
      'STAND': ['HIT'],
      'DOUBLE': ['HIT'],
      'SPLIT': ['HIT']
    };
    
    const options = alternatives[optimalAction] || ['STAND'];
    return options[Math.floor(Math.random() * options.length)];
  }
}

// 9. STRATEGY (con Illustrious 18)
class Strategy {
  static getOptimalPlay(playerHand, dealerCard, tc) {
    const myTotal = this.handValue(playerHand);
    const dealerValue = CARD_VALUES[dealerCard];
    const soft = this.isSoft(playerHand);
    const pair = this.isPair(playerHand);
    
    // Blackjack
    if(playerHand.length === 2 && myTotal === 21) {
      return { action: 'STAND', emoji: 'üéâ', reason: 'Blackjack natural (21)' };
    }
    
    // Bust
    if(myTotal > 21) {
      return { action: 'BUST', emoji: 'üí•', reason: 'Te pasaste de 21' };
    }
    
    // INSURANCE (Illustrious 18)
    if(dealerCard === 'A' && tc >= ILLUSTRIOUS_18.insurance) {
      return { action: 'INSURANCE', emoji: 'üõ°Ô∏è', reason: `Seguro TC‚â•+${ILLUSTRIOUS_18.insurance} (Ill-18)` };
    }
    
    // SURRENDER
    if(RULES.surrender && playerHand.length === 2) {
      if(myTotal === 16 && dealerValue >= 9) {
        return { action: 'SURRENDER', emoji: 'üè≥Ô∏è', reason: '16 vs 9/10/A: surrender' };
      }
      if(myTotal === 15 && dealerValue === 10) {
        return { action: 'SURRENDER', emoji: 'üè≥Ô∏è', reason: '15 vs 10: surrender' };
      }
    }
    
    // PAIRS
    if(pair) {
      const card = playerHand[0];
      if(card === 'A' || card === '8') {
        return { action: 'SPLIT', emoji: '‚úÇÔ∏è', reason: 'Siempre divide Ases y 8s' };
      }
      
      // 10,10 splits (Illustrious 18)
      if(CARD_VALUES[card] === 10) {
        if(dealerValue === 5 && tc >= ILLUSTRIOUS_18['20v5']) {
          return { action: 'SPLIT', emoji: '‚úÇÔ∏è', reason: `10,10 vs 5 TC‚â•+${ILLUSTRIOUS_18['20v5']} (Ill-18)` };
        }
        if(dealerValue === 6 && tc >= ILLUSTRIOUS_18['20v6']) {
          return { action: 'SPLIT', emoji: '‚úÇÔ∏è', reason: `10,10 vs 6 TC‚â•+${ILLUSTRIOUS_18['20v6']} (Ill-18)` };
        }
        return { action: 'STAND', emoji: '‚úã', reason: '20 excelente' };
      }
    }
    
    // SOFT HANDS
    if(soft) {
      if(myTotal >= 19) {
        return { action: 'STAND', emoji: '‚úã', reason: 'Soft 19+ muy fuerte' };
      }
      if(myTotal === 18) {
        if(dealerValue >= 9) {
          return { action: 'HIT', emoji: 'üëÜ', reason: 'Soft 18 vs 9/10/A: mejora' };
        }
        if(dealerValue >= 2 && dealerValue <= 6 && playerHand.length === 2) {
          return { action: 'DOUBLE', emoji: 'üí∞', reason: 'Soft 18 vs d√©bil: dobla' };
        }
        return { action: 'STAND', emoji: '‚úã', reason: 'Soft 18 aceptable' };
      }
      return { action: 'HIT', emoji: 'üëÜ', reason: 'Soft 17- pide' };
    }
    
    // HARD HANDS con Illustrious 18
    
    // 16 vs 10 (Illustrious 18)
    if(myTotal === 16 && dealerValue === 10) {
      if(tc >= ILLUSTRIOUS_18['16v10']) {
        return { action: 'STAND', emoji: '‚úã', reason: `16 vs 10 TC‚â•${ILLUSTRIOUS_18['16v10']} (Ill-18)` };
      }
      return { action: 'HIT', emoji: 'üëÜ', reason: '16 vs 10: pide (TC bajo)' };
    }
    
    // 15 vs 10 (Illustrious 18)
    if(myTotal === 15 && dealerValue === 10) {
      if(tc >= ILLUSTRIOUS_18['15v10']) {
        return { action: 'STAND', emoji: '‚úã', reason: `15 vs 10 TC‚â•+${ILLUSTRIOUS_18['15v10']} (Ill-18)` };
      }
      return { action: 'HIT', emoji: 'üëÜ', reason: '15 vs 10: pide' };
    }
    
    // 13 vs 2/3 (Illustrious 18)
    if(myTotal === 13) {
      if(dealerValue === 2 && tc >= ILLUSTRIOUS_18['13v2']) {
        return { action: 'STAND', emoji: '‚úã', reason: `13 vs 2 TC‚â•${ILLUSTRIOUS_18['13v2']} (Ill-18)` };
      }
      if(dealerValue === 3 && tc >= ILLUSTRIOUS_18['13v3']) {
        return { action: 'STAND', emoji: '‚úã', reason: `13 vs 3 TC‚â•${ILLUSTRIOUS_18['13v3']} (Ill-18)` };
      }
    }
    
    // 12 vs 2-6 (Illustrious 18)
    if(myTotal === 12) {
      if(dealerValue === 2 && tc >= ILLUSTRIOUS_18['12v2']) {
        return { action: 'STAND', emoji: '‚úã', reason: `12 vs 2 TC‚â•+${ILLUSTRIOUS_18['12v2']} (Ill-18)` };
      }
      if(dealerValue === 3 && tc >= ILLUSTRIOUS_18['12v3']) {
        return { action: 'STAND', emoji: '‚úã', reason: `12 vs 3 TC‚â•+${ILLUSTRIOUS_18['12v3']} (Ill-18)` };
      }
      if(dealerValue >= 4 && dealerValue <= 6) {
        return { action: 'STAND', emoji: '‚úã', reason: '12 vs 4-6: dealer d√©bil' };
      }
      return { action: 'HIT', emoji: 'üëÜ', reason: '12: pide' };
    }
    
    // 11 (Illustrious 18 + b√°sica)
    if(myTotal === 11) {
      if(dealerCard === 'A' && tc >= ILLUSTRIOUS_18['11vA'] && playerHand.length === 2) {
        return { action: 'DOUBLE', emoji: 'üí∞', reason: `11 vs A TC‚â•+${ILLUSTRIOUS_18['11vA']} (Ill-18)` };
      }
      if(playerHand.length === 2) {
        return { action: 'DOUBLE', emoji: 'üí∞', reason: '11 perfecto para doblar' };
      }
      return { action: 'HIT', emoji: 'üëÜ', reason: '11: pide' };
    }
    
    // 10 (Illustrious 18)
    if(myTotal === 10 && playerHand.length === 2) {
      if(dealerValue === 10 && tc >= ILLUSTRIOUS_18['10v10']) {
        return { action: 'DOUBLE', emoji: 'üí∞', reason: `10 vs 10 TC‚â•+${ILLUSTRIOUS_18['10v10']} (Ill-18)` };
      }
      if(dealerCard === 'A' && tc >= ILLUSTRIOUS_18['10vA']) {
        return { action: 'DOUBLE', emoji: 'üí∞', reason: `10 vs A TC‚â•+${ILLUSTRIOUS_18['10vA']} (Ill-18)` };
      }
      if(dealerValue >= 2 && dealerValue <= 9) {
        return { action: 'DOUBLE', emoji: 'üí∞', reason: '10 vs 2-9: dobla' };
      }
    }
    
    // 9 (Illustrious 18)
    if(myTotal === 9 && playerHand.length === 2) {
      if(dealerValue === 2 && tc >= ILLUSTRIOUS_18['9v2']) {
        return { action: 'DOUBLE', emoji: 'üí∞', reason: `9 vs 2 TC‚â•+${ILLUSTRIOUS_18['9v2']} (Ill-18)` };
      }
      if(dealerValue === 7 && tc >= ILLUSTRIOUS_18['9v7']) {
        return { action: 'DOUBLE', emoji: 'üí∞', reason: `9 vs 7 TC‚â•+${ILLUSTRIOUS_18['9v7']} (Ill-18)` };
      }
      if(dealerValue >= 3 && dealerValue <= 6) {
        return { action: 'DOUBLE', emoji: 'üí∞', reason: '9 vs 3-6: dobla' };
      }
    }
    
    // 17+
    if(myTotal >= 17) {
      return { action: 'STAND', emoji: '‚úã', reason: '17+ seguro' };
    }
    
    // 13-16
    if(myTotal >= 13 && myTotal <= 16) {
      if(dealerValue >= 2 && dealerValue <= 6) {
        return { action: 'STAND', emoji: '‚úã', reason: 'Dealer d√©bil: puede bustearse' };
      }
      return { action: 'HIT', emoji: 'üëÜ', reason: 'Dealer fuerte: mejora' };
    }
    
    return { action: 'HIT', emoji: 'üëÜ', reason: 'Total bajo: pide' };
  }
  
  static handValue(hand) {
    if(!hand || !hand.length) return 0;
    let total = 0, aces = 0;
    hand.forEach(c => {
      if(c === 'A') { total += 11; aces++; }
      else total += CARD_VALUES[c];
    });
    while(total > 21 && aces > 0) { total -= 10; aces--; }
    return total;
  }
  
  static isSoft(hand) {
    if(!hand || !hand.length) return false;
    let total = 0, aces = 0;
    hand.forEach(c => {
      if(c === 'A') { total += 11; aces++; }
      else total += CARD_VALUES[c];
    });
    return aces > 0 && total <= 21;
  }
  
  static isPair(hand) {
    return hand.length === 2 && CARD_VALUES[hand[0]] === CARD_VALUES[hand[1]];
  }
}

// 10. SIMULATOR (Auto-play)
class Simulator {
  static async playHand() {
    // Reparto inicial
    const playerCards = [shoe.draw(), shoe.draw()];
    const dealerCards = [shoe.draw()];
    
    state.lastHand = { player: playerCards, dealer: dealerCards };
    
    // Contar cartas
    playerCards.forEach(c => Counter.updateCount(c));
    dealerCards.forEach(c => Counter.updateCount(c));
    
    const tc = Counter.trueCount(state.runningCount, state.cardsPlayed, shoe.totalCards);
    const bet = Bankroll.getBet(tc);
    
    // Decisi√≥n del jugador
    let strategy = Strategy.getOptimalPlay(playerCards, dealerCards[0], tc);
    
    // Humanizer: ¬øerror intencional?
    if(Humanizer.shouldMakeError(tc, bet, state.handsPlayed)) {
      strategy.action = Humanizer.introduceError(strategy.action);
      strategy.reason += ' (ERROR HUMANO)';
    }
    
    // Completar dealer
    while(Strategy.handValue(dealerCards) < 17) {
      const card = shoe.draw();
      dealerCards.push(card);
      Counter.updateCount(card);
    }
    
    // Resultado
    const playerTotal = Strategy.handValue(playerCards);
    const dealerTotal = Strategy.handValue(dealerCards);
    
    let result = 'PUSH';
    if(playerTotal > 21) {
      result = 'LOSE';
      Bankroll.lose(bet);
    } else if(dealerTotal > 21) {
      result = 'WIN';
      Bankroll.win(bet);
    } else if(playerTotal > dealerTotal) {
      result = 'WIN';
      Bankroll.win(bet);
    } else if(playerTotal < dealerTotal) {
      result = 'LOSE';
      Bankroll.lose(bet);
    } else {
      Bankroll.push();
    }
    
    state.handsPlayed++;
    
    logEntry(`Mano #${state.handsPlayed}: ${result} | ${playerCards.join(',')} vs ${dealerCards.join(',')} | Apuesta: $${bet} | TC: ${tc}`);
    
    // Check shuffle
    if(shoe.needsShuffle(RULES.penetration)) {
      showAlert('üîÑ SHUFFLE DETECTADO - Penetraci√≥n alcanzada');
    }
    
    return { result, playerCards, dealerCards, bet, tc, strategy };
  }
}

// ==================== UI FUNCTIONS ====================

function renderCards() {
  const grid = document.getElementById('cardGrid');
  grid.innerHTML = '';
  
  ALL_CARDS.forEach(card => {
    const btn = document.createElement('button');
    btn.className = 'card';
    btn.textContent = card;
    btn.onclick = () => seeCard(card);
    
    const val = HI_LO[card];
    if(val > 0) btn.classList.add('low');
    else if(val < 0) btn.classList.add('high');
    else btn.classList.add('mid');
    
    grid.appendChild(btn);
  });
}

function seeCard(card) {
  Counter.updateCount(card);
  state.lastHand.player.push(card);
  
  logEntry(`Carta vista: ${card} | RC=${state.runningCount > 0 ? '+' + state.runningCount : state.runningCount}`);
  
  if(navigator.vibrate) navigator.vibrate(5);
  
  saveState();
  updateUI();
}

function updateUI() {
  const tc = Counter.trueCount(state.runningCount, state.cardsPlayed, shoe.totalCards);
  const bet = Bankroll.getBet(tc);
  const penetration = Math.round((state.cardsPlayed / shoe.totalCards) * 100);
  
  // Stats
  const rcEl = document.getElementById('rc');
  rcEl.textContent = state.runningCount > 0 ? '+' + state.runningCount : state.runningCount;
  rcEl.className = 'stat-value';
  if(state.runningCount > 0) rcEl.classList.add('positive');
  else if(state.runningCount < 0) rcEl.classList.add('negative');
  else rcEl.classList.add('neutral');
  
  const tcEl = document.getElementById('tc');
  tcEl.textContent = tc > 0 ? '+' + tc : tc;
  tcEl.className = 'stat-value';
  if(tc > 0) tcEl.classList.add('positive');
  else if(tc < 0) tcEl.classList.add('negative');
  else tcEl.classList.add('neutral');
  
  document.getElementById('bet').textContent = '$' + bet;
  
  const bankEl = document.getElementById('bank');
  bankEl.textContent = '$' + Math.round(state.currentBankroll);
  bankEl.className = 'stat-value';
  if(state.currentBankroll > RULES.bankroll) bankEl.classList.add('positive');
  else if(state.currentBankroll < RULES.bankroll) bankEl.classList.add('negative');
  else bankEl.classList.add('neutral');
  
  const penEl = document.getElementById('penetration');
  penEl.textContent = penetration + '%';
  penEl.className = 'stat-value';
  if(penetration >= RULES.penetration * 100) penEl.classList.add('warning');
  else penEl.classList.add('neutral');
  
  document.getElementById('mode').textContent = state.autoMode ? 'AUTO' : 'Manual';
  
  // Session stats
  document.getElementById('totalHands').textContent = state.handsPlayed;
  
  const profit = state.currentBankroll - RULES.bankroll;
  const profitEl = document.getElementById('profit');
  profitEl.textContent = (profit >= 0 ? '+' : '') + '$' + Math.round(profit);
  profitEl.style.color = profit >= 0 ? '#4ade80' : '#ef4444';
  
  const winRate = state.handsPlayed > 0 ? Math.round((state.handsWon / state.handsPlayed) * 100) : 0;
  document.getElementById('winRate').textContent = winRate + '%';
  
  // AI Advice
  updateAI();
  
  // Log
  updateLog();
}

function updateAI() {
  if(state.lastHand.player.length === 0 || state.lastHand.dealer.length === 0) {
    document.getElementById('aiAction').textContent = 'Esperando cartas...';
    document.getElementById('aiReason').textContent = 'Registra cartas para ver recomendaciones';
    return;
  }
  
  const tc = Counter.trueCount(state.runningCount, state.cardsPlayed, shoe.totalCards);
  const strategy = Strategy.getOptimalPlay(state.lastHand.player, state.lastHand.dealer[0], tc);
  
  document.getElementById('aiAction').textContent = strategy.emoji + ' ' + strategy.action;
  document.getElementById('aiReason').textContent = strategy.reason;
}

function logEntry(text) {
  const timestamp = new Date().toLocaleTimeString('es-CO');
  state.gameLog.push(`[${timestamp}] ${text}`);
  if(state.gameLog.length > 100) state.gameLog.shift();
}

function updateLog() {
  const logEl = document.getElementById('log');
  logEl.innerHTML = state.gameLog.map(entry => 
    `<div class="log-entry">${entry}</div>`
  ).reverse().join('');
}

function showAlert(text) {
  document.getElementById('alert').classList.remove('hidden');
  document.getElementById('alertText').textContent = text;
  setTimeout(() => document.getElementById('alert').classList.add('hidden'), 5000);
}

// ==================== ACTIONS ====================

async function toggleAuto() {
  state.autoMode = !state.autoMode;
  updateUI();
  
  if(state.autoMode) {
    logEntry('ü§ñ MODO AUTO-SIMULACI√ìN ACTIVADO');
    autoLoop();
  } else {
    logEntry('‚è∏Ô∏è Modo manual activado');
  }
}

async function autoLoop() {
  if(!state.autoMode) return;
  
  const result = await Simulator.playHand();
  updateUI();
  
  // Delay entre manos (300ms = r√°pido pero observable)
  setTimeout(autoLoop, 300);
}

function newHand() {
  state.lastHand = { player: [], dealer: [] };
  logEntry('‚è≠Ô∏è Nueva mano iniciada');
  updateUI();
}

function shuffle() {
  if(!confirm('¬øConfirmar SHUFFLE? Esto resetear√° RC y cartas jugadas.')) return;
  
  state.runningCount = 0;
  state.cardsPlayed = 0;
  shoe.reset();
  
  logEntry('üîÑ SHUFFLE - Conteo reseteado a 0');
  showAlert('üîÑ SHUFFLE completado - Zapato mezclado');
  
  saveState();
  updateUI();
}

function resetAll() {
  if(!confirm('¬øRESET TOTAL? Borra TODO: conteo, bankroll, historial.')) return;
  
  state = {
    runningCount: 0,
    cardsPlayed: 0,
    currentBankroll: RULES.bankroll,
    handsPlayed: 0,
    handsWon: 0,
    handsLost: 0,
    autoMode: false,
    gameLog: [],
    lastHand: { player: [], dealer: [] }
  };
  
  shoe.reset();
  localStorage.removeItem('bjState');
  
  logEntry('üí£ RESET TOTAL - Sistema reiniciado');
  updateUI();
}

function updateConfig() {
  RULES.decks = parseInt(document.getElementById('numDecks').value);
  RULES.penetration = parseInt(document.getElementById('penetrationPct').value) / 100;
  RULES.bankroll = parseFloat(document.getElementById('initialBank').value);
  RULES.minBet = parseFloat(document.getElementById('minBet').value);
  RULES.playMode = document.getElementById('playMode').value;
  RULES.errorRate = parseInt(document.getElementById('errorRate').value);
  RULES.dealerHitsSoft17 = document.getElementById('dealerHitsSoft17').checked;
  RULES.doubleAfterSplit = document.getElementById('doubleAfterSplit').checked;
  RULES.surrender = document.getElementById('surrender').checked;
  RULES.resplitAces = document.getElementById('resplitAces').checked;
  
  shoe = new Shoe(RULES.decks);
  state.currentBankroll = RULES.bankroll;
  
  saveConfig();
  logEntry('‚öôÔ∏è Configuraci√≥n actualizada');
  updateUI();
}

// ==================== PERSISTENCE ====================

function saveState() {
  localStorage.setItem('bjState', JSON.stringify(state));
}

function loadState() {
  const saved = localStorage.getItem('bjState');
  if(saved) {
    state = JSON.parse(saved);
  }
}

function saveConfig() {
  localStorage.setItem('bjConfig', JSON.stringify(RULES));
}

function loadConfig() {
  const saved = localStorage.getItem('bjConfig');
  if(saved) {
    const config = JSON.parse(saved);
    Object.assign(RULES, config);
    
    // Sync UI
    document.getElementById('numDecks').value = RULES.decks;
    document.getElementById('penetrationPct').value = RULES.penetration * 100;
    document.getElementById('initialBank').value = RULES.bankroll;
    document.getElementById('minBet').value = RULES.minBet;
    document.getElementById('playMode').value = RULES.playMode;
    document.getElementById('errorRate').value = RULES.errorRate;
    document.getElementById('dealerHitsSoft17').checked = RULES.dealerHitsSoft17;
    document.getElementById('doubleAfterSplit').checked = RULES.doubleAfterSplit;
    document.getElementById('surrender').checked = RULES.surrender;
    document.getElementById('resplitAces').checked = RULES.resplitAces;
  }
}

// ==================== INIT ====================

loadConfig();
loadState();
renderCards();
updateUI();

logEntry('‚úÖ Sistema cargado - Blackjack Counter Pro v2.0');
logEntry(`üìä Config: ${RULES.decks} mazos, ${Math.round(RULES.penetration*100)}% penetraci√≥n, Modo ${RULES.playMode}`);
</script>
</body>
</html>
